<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="pragma" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Scorecard</title>
    <style>
      html, body { margin:0; padding:0; background:transparent; }
      #wrap { display:flex; align-items:center; justify-content:center; width:100vw; height:100vh; }
      img { display:block; width:1280px; height:200px; object-fit:contain; }
      .msg { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color:#bbb; }
    </style>
    <script>
      // version beacon to verify you're seeing the latest page
      window.__OVERLAY_VERSION__ = "api-loader-v3";
      console.log("overlay version:", window.__OVERLAY_VERSION__);
    </script>
  </head>
  <body>
    <div id="wrap">
      <div id="status" class="msg">Loading…</div>
      <img id="card" alt="scorecard" style="display:none" />
    </div>

    <script>
      // ----- User from querystring -----
      const params = new URLSearchParams(location.search);
      let user = (params.get('user') || '').trim().toLowerCase();

      const statusEl = document.getElementById('status');
      const imgEl = document.getElementById('card');

      if (!user || !/^[a-z0-9._-]{2,32}$/.test(user)) {
        statusEl.textContent = 'Invalid or missing ?user=';
      } else {
        // ----- Repo settings -----
        const OWNER  = "Glover27";
        const REPO   = "biker-yoshi";
        const BRANCH = "main";
        const PATH   = `scorecards/${encodeURIComponent(user)}.png`;

        let lastHead = null;
        let headEtag = null; // ETag for the head ref request
        let imgEtag  = null; // ETag for the contents (image) request

        async function getHeadSha() {
          const headers = {};
          if (headEtag) headers["If-None-Match"] = headEtag;

          const r = await fetch(
            `https://api.github.com/repos/${OWNER}/${REPO}/git/ref/heads/${BRANCH}`,
            { headers, cache: "no-store" }
          );
          if (r.status === 304) return null; // unchanged head
          if (!r.ok) throw new Error("head ref fetch failed");

          headEtag = r.headers.get("ETag") || headEtag;
          const j = await r.json();
          return j.object.sha;
        }

        async function getImageBase64() {
          const headers = {};
          if (imgEtag) headers["If-None-Match"] = imgEtag;

          const r = await fetch(
            `https://api.github.com/repos/${OWNER}/${REPO}/contents/${PATH}?ref=${BRANCH}`,
            { headers, cache: "no-store" }
          );
          if (r.status === 304) return null; // not modified
          if (!r.ok) throw new Error("contents fetch failed");

          imgEtag = r.headers.get("ETag") || imgEtag;
          const j = await r.json();
          return j.content; // base64
        }

        async function refresh() {
          try {
            const head = await getHeadSha();
        
            // null => 304 Not Modified; only fetch image when head advances
            if (head && head !== lastHead) {
              const b64 = await getImageBase64();
              if (b64) {
                const next = new Image();
                // cache-bust in the URL fragment to guarantee a 'new' resource
                next.src = `data:image/png;base64,${b64.replace(/\n/g, "")}#${Date.now()}`;
        
                next.onload = () => {
                  // swap to the freshly loaded image (forces paint in OBS)
                  imgEl.src = next.src;
                  statusEl.style.display = 'none';
                  imgEl.style.display = 'block';
                };
              }
              lastHead = head;
            }
          } catch (e) {
            statusEl.textContent = 'Waiting for image…';
            imgEl.style.display = 'none';
          }
        }


        // Refresh right away, then poll.
        refresh();
        const intervalMs = 5000;
        setInterval(refresh, intervalMs);

        // Bonus: refresh immediately when tab becomes visible again
        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) refresh();
        });
      }
    </script>
  </body>
</html>
